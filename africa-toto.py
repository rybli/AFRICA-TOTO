import cv2
import argparse
import numpy
import glob
import os
from PIL import Image, ImageDraw
from multiprocessing import Process, Queue
import time

# TODO Flag option to save frames and map frame to row on HTML. Tool tip like window to show frame.


def extract_images(videosrc, imagedest, timeint=1):
    """
    Extracts frames from video source with a specified time interval (default: every frame).

    :param videosrc: input video file to be processed.
    :param imagedest: destination for video frames to be output for processing.
    :param timeint: time interval for video frame extraction (e.g. 1 = 1 frame extracted every second.) (default: every
    frame)
    :return: saved .jpg image files to imagedest location.
    """
    vidcap = cv2.VideoCapture(videosrc)
    print("Total video frames: ", vidcap.get(cv2.CAP_PROP_FRAME_COUNT))
    print("Video FPS: {:.2f}".format(vidcap.get(cv2.CAP_PROP_FPS), 3))
    print("Total video time: {:.2f} minutes".format(int(vidcap.get(cv2.CAP_PROP_FRAME_COUNT) /
                                                        vidcap.get(cv2.CAP_PROP_FPS)) / 60, 2))
    success, image = vidcap.read()
    count = 0

    # Save all frames to folder.
    print("Extracting frames...")
    while success:
        if args.time_interval:
            vidcap.set(cv2.CAP_PROP_POS_MSEC, (count * 1000))  # Capture frame every x seconds
        cv2.imwrite(imagedest + "\\%d.jpg" % count, image)  # save frame as JPEG file
        success, image = vidcap.read()
        count += timeint
    print("Finished extracting frames...")


def create_queue(imagedest):
    """
    Creates a multiprocessing queue for future multiprocessing work.

    :param imagedest: location of .jpg frames extracted from extract_images() function.
    :return: returns a multiprocessing queue for color information extraction later.
    """
    # put images into queue in order of modified time to no jumble up final image (chronological)
    for image in sorted(glob.glob(imagedest + "\\*"), key=os.path.getmtime):
        q.put(image)
    return q


def get_color(q):
    """
    Gather average color values for each frame of the queue.

    :param q: queue of images from create_queue() to process for color information.
    :return: returns list of average color information for final image processing.
    """
    color_array = []
    while not q.empty():
        myimg = cv2.imread(q.get())  # read frame
        avg_color_per_row = numpy.average(myimg, axis=0)  # get average per row
        avg_color = numpy.average(avg_color_per_row, axis=0)  # get average for whole image
        color_array.append(reversed(avg_color.astype(int)))
    return color_array


def create_final_image(colors, imgheight):
    """
    Create a barcode-like image of all average colors with the dimensions of:
    Length - Number of frames extracted
    Height - imgheight (default 650px)

    :param colors: list of average colors in each frame returned from get_colors() function.
    :param imgheight: height of final image in pixels (default is 650 pixels)
    :return: returns .PNG image with each average color value side by side (1px wide) vertically.
    """
    print("Processing final image...")
    finalimage = Image.new("RGB", (len(colors), imgheight))  # create blank canvas
    finalimagedraw = ImageDraw.Draw(finalimage)
    count = 0
    print("Drawing %d colors" % len(colors))
    for i in colors:
        finalimagedraw.line([(count, 0), (count, 1000)], fill=tuple(i))  # draw colors onto canvas
        count = count + 1
        finalimage.save(os.path.splitext(args.path_in)[0] + "_avgcolor_spectrum.PNG")
    print("Final image processed!")
    print("Final Image Dimensions: ", finalimage.size)


def clean_up(imagedest):
    """
    If --no-clean-up flag is set, extracted frame images will remain in imagedest folder, otherwise loop through
    destination and delete all.

    :param imagedest: destination of extracted frames from extract_frames() function.
    """
    if args.no_clean_up:
        print("Cleaning up generated frames...")
        generated_frames = os.listdir(imagedest)
        for frame in generated_frames:
            # TODO only delete files generated by extract_images()
            if frame.endswith(".jpg"):  # this will delete any .jpg in imagedest.
                os.remove(os.path.join(imagedest, frame))
        print("Cleanup Complete")


if __name__ == '__main__':
    a = argparse.ArgumentParser(description="Taken a given video file, output an image of average frame colors.")
    a.add_argument("--path-in", help="path to src video", required=True, type=str)
    a.add_argument("--path-out", help="path to dest image folder", required=True, type=str)
    a.add_argument("--time-interval", help="time interval to take frame capture. this will affect final image size",
                   type=int)
    a.add_argument("--img-height", help="image height of output file. default 650px. this will affect final image size",
                   type=int, nargs='?', const=650, default=650)
    a.add_argument("--no-clean-up", help="removes all captured frames to save space. default 'yes'",
                   action="store_false")
    args = a.parse_args()
    q = Queue()
    if not args.time_interval:
        s = time.perf_counter()
        extract_images(args.path_in, args.path_out)
        p = Process(target=get_color, args=(q,))
        create_final_image(get_color(create_queue(args.path_out)), args.img_height)
        clean_up(args.path_out)
        e = time.perf_counter() - s
        print(f"Executed in {e:0.2f} seconds.")
    else:
        s = time.perf_counter()
        extract_images(args.path_in, args.path_out, args.time_interval)
        p = Process(target=get_color, args=(q,))
        create_final_image(get_color(create_queue(args.path_out)), args.img_height)
        clean_up(args.path_out)
        e = time.perf_counter() - s
        print(f"Executed in {e:0.2f} seconds.")
